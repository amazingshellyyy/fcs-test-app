{"version":3,"sources":["fcs/fcswritestream.js","fcs/pollyfill.js","App.js","index.js","fcs/fcs.js","DropZone.js"],"names":["stream","require","util","FCS","FCSWriteStream","fcs","readableStream","Writable","call","this","highWaterMark","decodeStrings","objectMode","bytesRead","_w","state","eventsNeeded","meta","dataFormat","eventsToRead","DEFAULT_VALUES","isAnalysisThere","isAnalysisSegmentBeforeData","chunks","bytesNeeded","readParameters","encoding","prepareForData","buffer","_prepareReadParameters","bigSkip","bytesPerEvent","header","beginData","inherits","prototype","getFCS","_write","chunk","inEncodingIgnored","callback","string","push","length","Buffer","concat","_readHeader","endText","toString","beginText","text","_readTextOrAnalysis","_adjustHeaderBasedUponText","beginAnalysis","endAnalysis","analysis","_readData","Error","unpipe","emit","module","exports","includes","item","indexOf","App","className","DropZone","ReactDOM","render","StrictMode","document","getElementById","pollyfill","options","groupBy","dataAsStrings","dataAsNumbers","isBuffer","readBuffer","toJSON","json","Object","keys","SEGMENT","map","key","segmentName","JSON","stringify","join","delim","OPTION_VALUES","byParam","asNumber","asString","asBoth","asNone","byEvent","decimalsToPrint","maxPerLine","META","HEADER","TEXT","ANALYSIS","assign","databuf","moreOptions","textSegment","analysisSegment","get","segment","theSegment","firstMatchingKey","find","getAnalysis","getText","get$PnX","x","result","p","$PAR","getNumericData","idx","getStringData","getOnly","onlys","Array","isArray","i","s","split","s0","readStreamAsync","readStream","fws","prepareWriteableStream","pipe","on","err","isBE","$BYTEORD","events2Skip","Number","eventCount","$DATATYPE","fn","readDoubleBE","readDoubleLE","bytes","readFloatBE","readFloatLE","$P1B","readUInt32BE","readUInt32LE","readUInt16BE","readUInt16LE","skip","eventSkip","isFinite","Math","floor","computedSkip","_readDataGroupByEvent","dataNumbers","offset","bytesPerMeasurement","databufReadFn","numParams","e","v","eventString","dataStrings","dataE","toFixed","_readDataGroupByParam","dataArray","substring","fcsVersion","FCSVersion","trim","endData","charAt","asXML","delim2","needToHandleEscapees","splits","corrected","ic","delimCount","is","slenminus1","value","$MODE","inText","$TOT","$BEGINDATA","$ENDDATA","$BEGINANALYSIS","$ENDANALYSIS","MyDropzone","onDrop","useCallback","acceptedFiles","console","log","forEach","file","reader","FileReader","onabort","onerror","onload","binaryStr","from","FCSfile","readAsArrayBuffer","useDropzone","getRootProps","getInputProps","isDragActive"],"mappings":"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","file":"static/js/main.1a6b58da.chunk.js","sourcesContent":["/**\n * @author Morgan Conrad\n * Copyright(c) 2018\n * This software is released under the MIT license  (http://opensource.org/licenses/MIT)\n *\n * Helper class for FCS to provide a WriteableStream  for typical usage, see FCS.getWriteabletream\n *\n */\n\nconst stream = require(\"stream\");\nconst util = require(\"util\");\nconst FCS = require(\"./fcs\");\n\n/**\n * Constructor\n * @param fcs             optional, if null, a new one with default options is created\n * @param readableStream  optional, if provided, it will get unpiped as soon as possible\n * @constructor\n */\nfunction FCSWriteStream(fcs, readableStream) {\n  stream.Writable.call(this, {\n    highWaterMark: 262144,\n    decodeStrings: true,\n    objectMode: true,\n  });\n\n  this.fcs = fcs || new FCS();\n  this.readableStream = readableStream; // may be null\n\n  this.bytesRead = 0;\n\n  // lots of state variables while reading\n  this._w = {\n    state: \"header\",\n    eventsNeeded:\n      \"asNone\" === fcs.meta.dataFormat\n        ? 0\n        : fcs.meta.eventsToRead || FCS.DEFAULT_VALUES.eventsToRead,\n    isAnalysisThere: false,\n    isAnalysisSegmentBeforeData: false,\n    chunks: [],\n    bytesNeeded: 256,\n    readParameters: {},\n    encoding: fcs.meta.encoding || \"utf8\",\n\n    prepareForData: function(buffer) {\n      this.state = \"data\";\n      this.readParameters = fcs._prepareReadParameters(buffer);\n      return (\n        this.eventsNeeded *\n          (this.readParameters.bigSkip + this.readParameters.bytesPerEvent) +\n        fcs.header.beginData\n      );\n    },\n  };\n}\n\nutil.inherits(FCSWriteStream, stream.Writable);\n\nFCSWriteStream.prototype.getFCS = function() {\n  return this.fcs;\n};\n\nFCSWriteStream.prototype._write = function(chunk, inEncodingIgnored, callback) {\n  let fcs = this.fcs;\n  let fws = this;\n  let err = null;\n  let string;\n\n  let _w = this._w; // save typing...\n\n  if (\"done\" !== this._w.state) {\n    _w.chunks.push(chunk);\n    this.bytesRead += chunk.length;\n  }\n\n  // may do multiple steps at once, hence while\n  while (\"done\" !== _w.state && this.bytesRead >= _w.bytesNeeded) {\n    let buffer = Buffer.concat(_w.chunks);\n    _w.chunks = [buffer];\n\n    switch (_w.state) {\n      case \"header\":\n        fcs.header = fcs._readHeader(buffer);\n        _w.bytesNeeded = fcs.header.endText;\n        _w.state = \"text\";\n        break;\n\n      case \"text\":\n        string = buffer.toString(\n          _w.encoding,\n          fcs.header.beginText,\n          fcs.header.endText\n        );\n        fcs.text = fcs._readTextOrAnalysis(string);\n        fcs._adjustHeaderBasedUponText(fcs.text);\n\n        // look at TEXT to figure out what next\n        _w.isAnalysisThere = fcs.header.beginAnalysis > 0;\n        _w.isAnalysisSegmentBeforeData =\n          _w.isAnalysisThere && fcs.header.beginAnalysis < fcs.header.beginData;\n\n        if (_w.isAnalysisSegmentBeforeData) {\n          _w.state = \"analysis\";\n          _w.bytesNeeded = fcs.header.endAnalysis;\n        } else if (_w.eventsNeeded > 0) {\n          _w.bytesNeeded = _w.prepareForData(buffer);\n        } else {\n          _w.state = \"done\";\n        }\n        break;\n\n      case \"analysis\":\n        string = buffer.toString(\n          _w.encoding,\n          fcs.header.beginAnalysis,\n          fcs.header.endAnalysis\n        );\n        fcs.analysis = fcs._readTextOrAnalysis(string);\n\n        if (_w.isAnalysisSegmentBeforeData && _w.eventsNeeded > 0) {\n          _w.bytesNeeded = _w.prepareForData(buffer);\n        } else {\n          _w.state = \"done\";\n        }\n        break;\n\n      case \"data\":\n        fcs._readData(buffer, _w.readParameters);\n\n        if (_w.isAnalysisThere && !_w.isAnalysisSegmentBeforeData) {\n          _w.state = \"analysis\";\n          _w.bytesNeeded = fcs.header.endAnalysis;\n        } else {\n          _w.state = \"done\";\n        }\n        break;\n\n      default: throw Error(\"oops\");\n    }\n  } // end of while loop\n\n  if (\"done\" !== _w.state) callback(err);\n  else {\n    if (this.readableStream) {\n      this.readableStream.unpipe(this);\n      this.emit(\"finish\");\n    } else callback(); // can't turn off the spigot, keep reading\n  }\n};\n\nmodule.exports = FCSWriteStream;\n","const pollyfill = {\n  includes: function(item){\n    return item.indexOf('2,1') > -1;\n  },\n}\n\nmodule.exports = pollyfill;\n","import './App.css';\nimport DropZone from './DropZone'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      IE sucks 5\n      <DropZone/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n// require('es6-promise').polyfill();\nrequire('core-js/features/promise');       // for promise\nrequire('core-js/es/object/assign');       // for assign\nrequire('core-js/es/array/includes');      // for includes\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n","/**\n * @author Morgan Conrad\n * Copyright(c) 2018\n * This software is released under the MIT license  (http://opensource.org/licenses/MIT)\n */\n\nconst FCSWriteStream = require(\"./fcswritestream\");\nconst pollyfill = require(\"./pollyfill\");\n/**\n * Constructor\n * @param options   options,  {}, optional argument\n * @param buffer   if present, read it.  (Otherwise, call readFCS() later)\n * @constructor\n */\nfunction FCS(/* optional */ options, buffer) {\n\n  // allow \"static\" usage, save user from misuse...\n  if (!(this instanceof FCS)) return new FCS(options, buffer);\n\n  // important options to always have in meta so they get remembered\n  this.meta = {\n    dataFormat: FCS.DEFAULT_VALUES.dataFormat,\n    groupBy: FCS.DEFAULT_VALUES.groupBy,\n  };\n\n  this.header = {};\n  this.text = {};\n  this.analysis = {};\n  this.bytesRead = 0;\n\n  this.dataAsStrings = null;\n  this.dataAsNumbers = null;\n\n  this.options(options);\n\n  if (buffer) {\n    if (Buffer.isBuffer(buffer))\n      this.readBuffer(buffer);\n    else\n      throw Error(\"only Buffers supported for now\");\n  }\n\n  // override the toJSON() method\n  this.toJSON = function() {\n    // collect meta, header, text, and analysis\n    let segmentVals = Object.keys(FCS.SEGMENT).map((key) => {\n      let segmentName = FCS.SEGMENT[key];\n      return '\"' + segmentName + ': \"' + JSON.stringify(this[segmentName], null, 2);\n    });\n    let json = '{\\n ' + segmentVals.join(',\\n ');\n\n    json += ',\\n \"data\": \\n';\n    if (this.dataAsStrings) {\n      // for clarity, an extra CRLF after groupByParam data\n      let delim =\n        FCS.OPTION_VALUES.byParam === this.meta.groupBy ? \",\\n\\n\" : \",\\n\";\n      json += \"[\";\n      json += this.dataAsStrings.join(delim);\n      json += \"]\";\n    } else if (this.dataAsNumbers)\n      json += JSON.stringify(this.dataAsNumbers, null, 2);\n\n    json += \"\\n}\"; // close\n    return json;\n  };\n}\n\n/*\n * Constants for possible incoming option/meta values\n * Also see the defaults below in FCS.DEFAULT_VALUES\n */\nmodule.exports.OPTION_VALUES = FCS.OPTION_VALUES = {\n  // .dataFormat should hold one of the following:\n  asNumber: \"asNumber\", // collect data in large numeric arrays\n  asString: \"asString\", // default, just collect data as a String (e.g. all you want is JSON back)\n  asBoth: \"asBoth\", // both\n  asNone: \"asNone\", // skip all the data\n\n  // .groupBy   should hold one of the following:\n  byEvent: \"byEvent\", // data values for each event are grouped together\n  byParam: \"byParam\", // data values for each parameter are grouped together\n\n  /*\n          Other option keys that we use are\n\n          .decimalsToPrint   0 means \"all events\", default = 1000\n\n          .eventsToLoad      0 means none, negative means all\n\n          .maxPerLine        affects printing in byParam for readability\n\n          .encoding          should always be 'utf8' for FCS format\n\n\n          All other options are ignored by this code, but will be placed into meta.\n          So you will see them in the JSON.  In this way you can add your own metadata\n          such as the date, laboratory, the filename, error status, etc...\n     */\n};\n\n/*\n * Default values for the options we use.  In general, you should treat these as constants,\n * but if you really want to change the default behavior I can't stop you...\n */\nmodule.exports.DEFAULT_VALUES = FCS.DEFAULT_VALUES = {\n  decimalsToPrint: 2, // 0 means \"all events\"\n  encoding: \"utf8\",\n  eventsToRead: 1000, // an integer, 0 means \"all events\"\n  maxPerLine: 10, // only applies in byParam mode\n  dataFormat: \"asString\", // alternatives are 'asNumber', 'asBoth', 'asNone'\n  groupBy: \"byEvent\", // alternative is 'byParam'\n};\n\nmodule.exports.SEGMENT = FCS.SEGMENT = {\n  META: \"meta\",\n  HEADER: \"header\",\n  TEXT: \"text\",\n  ANALYSIS: \"analysis\",\n};\n\n/**\n * Adds properties from options to our meta data, overwriting if necessary\n * @param options   if absent nothing happens.\n * @returns {FCS}   for convenience\n */\nFCS.prototype.options = function(options) {\n  Object.assign(this.meta, options);\n  return this;\n};\n\n/**\n * Main method at creation, reads an FCS format file from a databuf\n *\n * @param databuf       required\n * @param moreOptions   optional\n * @returns {FCS}       for convenience\n */\nFCS.prototype.readBuffer = function(databuf, /* optional */ moreOptions) {\n  // add any moreOptions,  meta is now \"complete\"\n  this.options(moreOptions);\n\n  let encoding = this.meta.encoding || FCS.DEFAULT_VALUES.encoding;\n  this.header = this._readHeader(databuf, encoding);\n\n  let textSegment = databuf.toString(\n    encoding,\n    this.header.beginText,\n    this.header.endText,\n  );\n  this.text = this._readTextOrAnalysis(textSegment);\n\n  this._adjustHeaderBasedUponText(this.text);\n\n  if (this.header.beginAnalysis) {\n    let analysisSegment = databuf.toString(\n      encoding,\n      this.header.beginAnalysis,\n      this.header.endAnalysis,\n    );\n    this.analysis = this._readTextOrAnalysis(analysisSegment);\n  }\n\n  // TODO  supplemental text, e.g. $BEGINSTEXT, $ENDSTEXT\n\n  this.dataAsNumbers = null;\n  this.dataAsStrings = null;\n\n  this._readData(databuf);\n\n  return this;\n};\n\n// here follow the public \"getters/accessor\" methods\n\n/**\n * All purpose get, called by the other methods\n * @param segment   one of FCS.SEGMENT  (typically 'text',analysis', more rarely 'meta','header')\n * @param keys      if none, returns the entire segment\n *                  otherwise, return first property match\n * @returns         {} if no-arg, else String, null if none were found.\n */\nFCS.prototype.get = function(segment, ...keys) {\n  let theSegment = this[segment];\n  if (!keys.length) return theSegment;\n\n  let firstMatchingKey = keys.find((key) => theSegment[key]);\n  return firstMatchingKey ?\n    theSegment[firstMatchingKey] :\n    null;\n};\n\n/**\n * If no arguments are provided, returns *all* the ANALYSIS segment (may be {})\n * Otherwise, returns a single value from the ANALYSIS segment.\n *    e.g.   analysis('GATE1 count') ->  '1234'\n * @param keys     varargs, returns first \"hit\"\n * @returns       {} if no-arg, else String, null if none were found.\n */\nFCS.prototype.getAnalysis = function(...keys) {\n  return this.get(FCS.SEGMENT.HEADER, ...keys);\n};\n\n/**\n * If no arguments are provided, returns *all* the TEXT segment.\n *Otherwise, returns a single value from the TEXT segment.\n *    e.g.   getText('$CYT') ->  'FACSort'\n * @param keys     varargs,  returns first \"hit\"\n * @returns       {} if no-arg, else String, null if none were found.\n */\nFCS.prototype.getText = function(...keys) {\n  return this.get(FCS.SEGMENT.TEXT, ...keys);\n};\n\n/**\n * Returns an entire array of values from the text segment,\n * The returned array has 1 based indexing\n *    e.g.   get$PnX('N') => [,'FSC-H','SSC-H','FL1-H', etc...]\n * @param x\n * @returns {Array}\n */\nFCS.prototype.get$PnX = function(x) {\n  let result = [];\n  result[0] = null;\n  for (let p = 1; p <= this.meta.$PAR; p++)\n    result[p] = this.text[\"$P\" + p + x];\n\n  return result;\n};\n\n/**\n * Returns numeric data if it was collected   (i.e. meta.dataFormat was asNumber or asBoth)\n * Whether this is the event[idx] or the parameter[idx] depends on meta.groupBy.\n * @param idx   1-based.\n * @returns {[]} of Numbers\n */\nFCS.prototype.getNumericData = function(idx) {\n  return (this.dataAsNumbers) ?\n    this.dataAsNumbers[idx - 1] :\n    null;\n};\n\n/**\n * Returns string data if it was collected   (i.e. meta.dataFormat was asString or asBoth)\n * Whether this is the event[idx] or the parameter[idx] depends on meta.groupBy.\n * @param idx   1-based.\n * @returns {[]}  of Strings\n */\nFCS.prototype.getStringData = function(idx) {\n  return (this.dataAsStrings) ?\n    this.dataAsStrings[idx - 1] :\n    null;\n};\n\n/**\n * Return an shallow copy object of a smallish subset of us\n * @param onlys[]   dot delimited Strings, e.g. 'meta' to get all of meta, 'text.$P1N' to get parameter 1 name\n * @returns {{}}    will be empty if onlys is empty\n */\nFCS.prototype.getOnly = function(onlys) {\n  // if only one, force to an array...\n  if (!Array.isArray(onlys)) onlys = [onlys];\n  let result = {};\n  for (let i = 0; i < onlys.length; i++) {\n    let s = onlys[i].split(\".\", 2); // we only go 1 or 2 deep\n    let s0 = s[0];\n    if (s.length === 1) {\n      // copy everything\n      result[s0] = this[s0];\n    } else {\n      if (!result[s0]) result[s0] = {};\n      result[s0][s[1]] = this[s0][s[1]];\n    }\n  }\n\n  return result;\n};\n\n/**\n * Read asynchronously, using an FCSWriteableStream.\n * @param readStream   required\n * @param moreOptions  optional\n * @param callback     if present, callback(err, fcs) gets called at the end.\n */\nFCS.prototype.readStreamAsync = function(readStream, moreOptions, callback) {\n  let self = this;\n  let fws = this.prepareWriteableStream(callback, readStream);\n  this.options(moreOptions);\n\n  readStream.pipe(fws);\n};\n\n/**\n * Prepares a writeableStream for use with this FCS\n * if a callback is provided, all you need do is readableStream.pipe(fws);\n *\n * @param callback         if present, it will get called back with (err, fcs)\n * @param readableStream   if present, may get closed sooner...\n * @returns {FCSWriteStream}\n */\nFCS.prototype.prepareWriteableStream = function(callback, readableStream) {\n  let fws = new FCSWriteStream(this, readableStream);\n  if (callback) {\n    fws.on(\"finish\", function(err) {\n      callback(err, fws.fcs); // access the underlying fcs via  fws.getFCS()\n    });\n    fws.on(\"error\", function(err) {\n      callback(err, fws.fcs);\n    });\n  }\n\n  return fws;\n};\n\n// here follow private methods\n\n/**\n * Decides various parameters and methods based upon our options\n * @param databuf\n * @returns {{asNumber: boolean, asString: boolean, decimalsToPrint: number, bigSkip: number}}\n * @private\n */\nFCS.prototype._prepareReadParameters = function(databuf) {\n  let isBE;\n  if (pollyfill.includes(this.text.$BYTEORD)) isBE = true;\n  else if (pollyfill.includes(this.text.$BYTEORD)) isBE = false;\n  else throw Error(\"cannot handle $BYTEORD= \" + this.text.$BYTEORD);\n\n  let options = this.meta;\n\n  let readParameters = {\n    asNumber:\n      FCS.OPTION_VALUES.asNumber === options.dataFormat ||\n      FCS.OPTION_VALUES.asBoth === options.dataFormat,\n    asString:\n      FCS.OPTION_VALUES.asString === options.dataFormat ||\n      FCS.OPTION_VALUES.asBoth === options.dataFormat,\n    decimalsToPrint: Number(\n      options.decimalsToPrint || FCS.DEFAULT_VALUES.decimalsToPrint\n    ),\n    bigSkip: 0,\n  };\n\n  readParameters.eventsToRead = Number(\n    options.eventsToRead || FCS.DEFAULT_VALUES.eventsToRead\n  );\n  if (\n    readParameters.eventsToRead <= 0 ||\n    readParameters.eventsToRead > this.meta.eventCount\n  )\n    readParameters.eventsToRead = this.meta.eventCount;\n\n  switch (this.text.$DATATYPE) {\n    case \"D\":\n      readParameters.fn = isBE ? databuf.readDoubleBE : databuf.readDoubleLE;\n      readParameters.bytes = 8;\n      break;\n    case \"F\":\n      readParameters.fn = isBE ? databuf.readFloatBE : databuf.readFloatLE;\n      readParameters.bytes = 4;\n      break;\n    case \"I\":\n      let bits = Number(this.text.$P1B);\n      if (bits > 16) {\n        readParameters.fn = isBE ? databuf.readUInt32BE : databuf.readUInt32LE;\n        readParameters.bytes = 4;\n      } else {\n        readParameters.fn = isBE ? databuf.readUInt16BE : databuf.readUInt16LE;\n        readParameters.bytes = 2;\n      }\n      break;\n    default:\n      throw Error(\"oops\");\n  }\n\n  readParameters.bytesPerEvent = readParameters.bytes * this.meta.$PAR;\n\n  options.skip = options.skip || options.eventSkip; // fix bug#4\n  if (options.skip && readParameters.eventsToRead < this.meta.eventCount) {\n    let events2Skip;\n    if (Number.isFinite(options.skip)) events2Skip = options.skip;\n    else {\n      // FIXME, doesn't actually work\n      events2Skip =\n        Math.floor(this.meta.eventCount / readParameters.eventsToRead) - 2;\n      this.meta.computedSkip = options.skip + \" -> \" + events2Skip;\n    }\n    readParameters.bigSkip = events2Skip * readParameters.bytesPerEvent;\n  }\n\n  return readParameters;\n};\n\n/**\n * Read data and group 1st by event (the natural order in the file)\n *\n * @param databuf  required\n * @param readParameters  optional\n * @returns {FCS}  for convenience\n */\nFCS.prototype._readDataGroupByEvent = function(databuf, readParameters) {\n\n  // determine if these are ints, floats, etc...\n  readParameters = readParameters || this._prepareReadParameters(databuf);\n\n  let offset = Number(this.header.beginData);\n\n  // local cache since heavily used\n  let bytesPerMeasurement = readParameters.bytes;\n  let databufReadFn = readParameters.fn;\n  let eventsToRead = readParameters.eventsToRead;\n  let numParams = Number(this.meta.$PAR);\n  let decimalsToPrint =\n    \"I\" === this.text.$DATATYPE ? -1 : readParameters.decimalsToPrint;\n\n  let e = Number;\n  let p = Number;\n  let v = Number;\n\n  let dataNumbers;\n  if (readParameters.asNumber) {\n    dataNumbers = new Array(eventsToRead);\n    for (e = 0; e < eventsToRead; e++) dataNumbers[e] = new Array(numParams);\n  }\n\n  let dataStrings = readParameters.asString ? new Array(eventsToRead) : null;\n  let eventString;\n\n  // loop over each event\n  for (e = 0; e < eventsToRead; e++) {\n    if (dataStrings) {\n      eventString = \"[\";\n    }\n    let dataE = dataNumbers ? dataNumbers[e] : null; // efficiency\n\n    // loop over each parameter\n    for (p = 0; p < numParams; p++) {\n      v = databufReadFn.call(databuf, offset);\n      offset += bytesPerMeasurement;\n\n      if (dataStrings) {\n        if (p > 0) eventString += \",\";\n        if (decimalsToPrint >= 0) eventString += v.toFixed(decimalsToPrint);\n        else eventString += v;\n      }\n\n      if (dataE) dataE[p] = v;\n    }\n\n    if (dataStrings) {\n      eventString += \"]\";\n      dataStrings[e] = eventString;\n    }\n\n    offset += readParameters.bigSkip;\n  }\n\n  this.dataAsNumbers = dataNumbers;\n  this.dataAsStrings = dataStrings;\n  return this;\n};\n\n/**\n * Read data and group 1st by parameter\n *\n * @param databuf   required\n * @param readParameters   optional\n * @returns {FCS}   for convenience\n */\nFCS.prototype._readDataGroupByParam = function(databuf, readParameters) {\n\n  readParameters = readParameters || this._prepareReadParameters(databuf);\n\n  let offset = Number(this.header.beginData);\n\n  // local cache since heavily used\n  let bytesPerMeasurement = readParameters.bytes;\n  let databufReadFn = readParameters.fn;\n  let eventsToRead = readParameters.eventsToRead;\n  let numParams = Number(this.meta.$PAR);\n  let decimalsToPrint =\n    \"I\" === this.text.$DATATYPE ? -1 : readParameters.decimalsToPrint;\n\n    let maxPerLine = Number(\n    this.meta.maxPerLine || FCS.DEFAULT_VALUES.maxPerLine\n  );\n\n  let e = Number;\n  let p = Number;\n  let v = Number;\n\n  let dataArray;\n  if (readParameters.asNumber) {\n    dataArray = new Array(eventsToRead);\n    for (e = 0; e < eventsToRead; e++) dataArray[e] = new Array(numParams);\n  }\n  let dataStrings;\n  if (readParameters.asString) {\n    dataStrings = [];\n    for (p = 0; p < numParams; p++) dataStrings[p] = \"[\";\n  }\n\n  for (e = 0; e < eventsToRead; e++) {\n    for (p = 0; p < numParams; p++) {\n      v = databufReadFn.call(databuf, offset);\n      offset += bytesPerMeasurement;\n      if (dataArray) dataArray[p][e] = v;\n      if (dataStrings) {\n        if (e > 0) {\n          dataStrings[p] += \",\";\n          if (e % maxPerLine === 0) dataStrings[p] += \"\\n\";\n        }\n\n        if (decimalsToPrint >= 0) dataStrings[p] += v.toFixed(decimalsToPrint);\n        else dataStrings[p] += v;\n      }\n    }\n\n    offset += readParameters.bigSkip;\n  }\n\n  if (dataStrings) {\n    for (p = 0; p < numParams; p++) {\n      dataStrings[p] =\n        dataStrings[p].substring(0, dataStrings[p].length - 1) + \"]\";\n    }\n  }\n\n  this.dataAsNumbers = dataArray;\n  this.dataAsStrings = dataStrings;\n\n  return this;\n};\n\n/**\n * Read the header segment (the first 256 bytes)\n *\n * @param databuf   required\n * @param encoding  usually absent, defaults to utf8\n * @returns {} (see header variable for details)\n * @private\n */\nFCS.prototype._readHeader = function(databuf, encoding = \"utf8\") {\n\n  let fcsVersion = databuf.toString(encoding, 0, 6);\n  if (\"FCS\" !== fcsVersion.substring(0, 3)) {\n    throw Error(\"Bad FCS Version: \" + fcsVersion);\n  }\n\n  let header = {\n    FCSVersion: fcsVersion,\n    beginText: Number(databuf.toString(encoding, 10, 18).trim()),\n    endText: Number(databuf.toString(encoding, 18, 26).trim()),\n    beginData: Number(databuf.toString(encoding, 26, 34).trim()),\n    endData: Number(databuf.toString(encoding, 34, 42).trim()),\n    beginAnalysis: Number(databuf.toString(encoding, 42, 50).trim()),\n    endAnalysis: Number(databuf.toString(encoding, 50, 58).trim()),\n  };\n\n  return header;\n};\n\n/**\n * Reads the delimited key/value pairs of a TEXT or ANALYSIS segment\n * @param string   if falsy returns empty object\n * @returns {{}}\n */\nFCS.prototype._readTextOrAnalysis = function(string) {\n  let result = {};\n\n  if (!string) return result;\n\n  let delim = string.charAt(0);\n\n  if (\"<\" === delim) {\n    // Millipore puts in ANALYSIS as XML, don't try to split it up  (TODO use xml2js)\n    result.asXML = string;\n    return result;\n  }\n\n  // test for escaped delimiters\n  let delim2 = delim + delim;\n  let needToHandleEscapees = string.indexOf(delim2) > 0;\n  let splits = string.split(delim);\n\n  // messy code...\n  if (needToHandleEscapees) {\n    let corrected = [\"\", \"\"];\n    let ic = 0;\n    let delimCount = 0;\n    for (let is = 1; is < splits.length; is++) {\n      let s = splits[is];\n      if (s) {\n        if (delimCount) {\n          while (delimCount > 0) {\n            corrected[ic] += delim;\n            delimCount -= 2; //  a '////' will give 3 blanks but only two // are desired\n          }\n\n          if (delimCount === 0)\n            // odd number is poorly defined, let's make do...\n            corrected[++ic] = s;\n          else corrected[ic] += s;\n          delimCount = 0;\n        } else corrected[++ic] = s;\n      } else {\n        delimCount++;\n      }\n    }\n\n    splits = corrected;\n  }\n\n  // If string ended with the delimiter, there's an extra empty value.  Remove it.\n  let slenminus1 = splits.length - 1;\n  if (!splits[slenminus1]) splits.length = slenminus1;\n\n  // Grab all the key/value pairs.  Start at 1 cause split also added a blank field at the beginning\n  for (let i = 1; i < splits.length; i += 2) {\n    let key = splits[i].trim(); // Partec puts \\n before analysis keywords\n    let value = splits[i + 1];\n    result[key] = value;\n  }\n\n  return result;\n};\n\nFCS.prototype._readData = function(databuf, readParameters) {\n  if (\n    \"H\" === this.text.$MODE ||\n    FCS.OPTION_VALUES.asNone === this.meta.dataFormat\n  )\n    return this;\n\n  readParameters = readParameters || this._prepareReadParameters(databuf);\n\n  if (FCS.OPTION_VALUES.byParam === this.meta.groupBy)\n    this._readDataGroupByParam(databuf, readParameters);\n  else this._readDataGroupByEvent(databuf, readParameters);\n\n  return this;\n};\n\n/**\n * FCS 3.0 added support for huge files, where the actual DATA segment may be described in the TEXT segment\n * Also sets meta.eventCount and meta.$PAR since they are used so often\n *\n * @param inText\n * @private\n */\nFCS.prototype._adjustHeaderBasedUponText = function(inText) {\n  inText = inText || this.text;\n\n  // update a few important meta.\n  this.meta.eventCount = Number(inText.$TOT);\n  this.meta.$PAR = Number(inText.$PAR);\n\n  // possibly adjust data and analysis headers for huge files\n  if (this.header.beginData === 0) {\n    this.header.beginData = Number(inText.$BEGINDATA);\n    this.header.endData = Number(inText.$ENDDATA);\n  }\n  if (this.header.beginAnalysis === 0) {\n    this.header.beginAnalysis = Number(inText.$BEGINANALYSIS || 0);\n    this.header.endAnalysis = Number(inText.$ENDANALYSIS || 0);\n  }\n};\n\nmodule.exports = FCS;\n","import React, { useCallback } from 'react'\nimport { useDropzone } from 'react-dropzone'\nconst FCS = require('./fcs/fcs')\nfunction MyDropzone() {\n  const onDrop = useCallback(acceptedFiles => {\n    // Do something with the files\n    console.log('acceptedFiles', acceptedFiles)\n    acceptedFiles.forEach((file) => {\n      const reader = new FileReader()\n\n      reader.onabort = () => console.log('file reading was aborted')\n      reader.onerror = () => console.log('file reading has failed')\n      reader.onload = () => {\n      // Do whatever you want with the file contents\n        console.log('reader', reader)\n        // arrayBuffer\n        const binaryStr = reader.result\n        console.log('binaryStr', binaryStr)\n        const buffer = Buffer.from(binaryStr, 'binary')\n        console.log('buffer', buffer)\n        const FCSfile = new FCS({}, buffer)\n        console.log('FCSfile', FCSfile)\n      }\n      console.log('file', file)\n      reader.readAsArrayBuffer(file)\n    })\n  }, [])\n  const {getRootProps, getInputProps, isDragActive} = useDropzone({onDrop})\n\n  return (\n    <div {...getRootProps()}>\n      <input {...getInputProps()} />\n      {\n        isDragActive ?\n          <p>Drop the files here ...</p> :\n          <p>Drag 'n' drop some files here, or click to select files</p>\n      }\n    </div>\n  )\n}\n\nexport default MyDropzone\n"],"sourceRoot":""}